<DOCTYPE html>
  <html lang="en">
    <head>

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>David Russell's Portfolio</title>
        <link rel="shortcut icon"  type="image/png" href="../img/favicon.png"/>


        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.win.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.css">

        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap">
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap">
        <link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />

        <link rel="stylesheet" href="../css/style.css">

    </head>

    <body>


        <!--Introduction-->
        <section class="intro" id="home">
            <h1 class="section__title section__title--intro">
                Paging Simulator
            </h1>
            <p  class="section__subtitle section__subtitle--intro section__subtitle--intro-project" >for virtual memory management</p>

            <img src="../images/projects/paging/cover.jpg" alt="cover" data-aos="fade-in" data-aos-duration="1500" class="intro__img inline-photo">




        </section>



        <div style="margin-bottom: 0em" class="links__list">
          <div style="height:5em"class = "buffer"></div>
          <li class="nav__item"><a href="../index.html" class="nav__link">Home</a></li>
          <li class="nav__item"><a href="../index.html#projects" class="nav__link">Projects</a></li>
          <li class="nav__item"><a href="../index.html#resume" class="nav__link">Resume</a></li>
          <li class="nav__item"><a href="../index.html#aboutme" class="nav__link">About Me</a></li>
          <li class="nav__item"><a href="../index.html#contact" class="nav__link">Contact Me</a></li>
        </div>
        <div class = "buffer underlinks"></div>
        <div class="project-body">
          <div class="project-body">
            <p></p>
            <div style="display:flex"class="portfolio-item-individual">
          <a class = "button" href="https://github.com/dmruss/PagingSim">Click here to view the GitHub repo.</a>

        </div>
        </div>
        </div>

        <div class="portfolio-item-individual">

          <p></p>
          <img class="portfolio-item-individual-image image_tall"src="../images/projects/paging/input.JPG">
          <p style = "font-size: 25px; color:black" class="portfolio-item-individual-description">This project is a simulation program of virtual memory replacement algorithms written in C++. The algorithms are First in First Out (FIFO), Least Recently Used (LRU), and Optimal page replacement (OPT). This program runs simulations of each algorithm with a input file and reports on the their performance. These algorithms are run in comparison with each other and also with different frame sizes. The program is run 4 times with 4 different page sizes (128, 256, 512, and 1024). The main interest is in how many page faults are generated by each algorithm with each page size.</p>
          <p></p>
        </div>





        <div class="portfolio-item-individual">
          <p></p>
          <img class="portfolio-item-individual-image image_wide"src="../images/projects/paging/output.JPG">

          <p></p>
        </div>

        <div class="portfolio-item-individual">
        <div style="grid-column: 1/ -1; color:black" class="portfolio-item-individual-description"
        <p><strong>Key Algorithms</strong></p>
        <p><strong>First In First Out</strong></p>
        <p>The FIFO algorithm is the simplest virtual memory algorithm. Its behavior is exactly like that of a FIFO queue when it comes to replacement.

When a page is referenced, it checks if that page is already in memory. If it is then it moves on to the next page in the queue.

If a page is not in memory, then it checks if there are any free frames. If so, it is added to memory. This is counted as a page fault.

If a page is not in memory and there are no free frames, then FIFO is put to work. The oldest page in memory is removed and then the new page is added. The oldest page is found at the head of the queue. This is counted as a page fault.</p>
      <p><strong>Least Recently Used</strong></p>
      <p>The LRU algorithm improves slightly upon FIFO by removing the page in memory which was used the farthest back in time. This is based on the idea that recent behavior may be a good predictor of future behavior.

When a page is referenced, it checks if that page is in memory. If it is, then it is moved to the tail of the queue. Because the frame queue is dequeued at the head, adding a recently used page to the tail creates a sort of priority queue by use times.

If a page is not in memory and there is a free frame, it is added to the tail. This is counted as a page fault.

If a page is not in memory and there are no free frames, the head is dequeued and the new page is enqueued at the tail. Also, a page fault.</p>
      <p><strong>Optimal Page Replacement</strong></p>
      <p>This algorithm is only possible in a hypothetical environment such as this simulation. Future page references are used to tell the algorithm which pages to remove from memory. The page which is in memory but either used farthest in the future or not again is removed from memory.

When a page is referenced, it will check if it is in memory. If so it will move to the next page.

If the page is not in memory and there is a free frame, it is added to the tail. This is another page fault.

If a page is not in memory and there are no free frames, OPT iterates through each page in memory and through all future page references to assign each page in memory a priority number. The priority number is the soonest that page is referenced from the current page. If it is not referenced again, it receives a priority of -1. The first page to receive a priority of -1 is chosen as the victim. If there are no pages with a priority of -1, then the highest integer priority number is the victim. The page fault counter is incremented.</p>
      </div>
        </div>

        <div class="portfolio-item-individual-maps-container">

          <style>
          .portfolio-item-individual-maps-container {
            display:grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 2fr));

          }
          @media (min-width: 1000px) {
            .portfolio-item-individual-maps-container {

              display:grid;
              grid-template-columns: repeat(2, 500px);
              justify-content: center;

            }

          }
          </style>


          <img  class="portfolio-item-individual-image-map-grid"src="../images/projects/paging/fifograph.JPG">
          <img  class="portfolio-item-individual-image-map-grid"src="../images/projects/paging/lrugraph.JPG">
          <img  class="portfolio-item-individual-image-map-grid"src="../images/projects/paging/optgraph.JPG">


        </div>

        <p></p>
        <div class="portfolio-item-individual">
        <div style="grid-column: 1/ -1; color:black" class="portfolio-item-individual-description">
        <p>Overall, FIFO and LRU were surprisingly similar in this simulation.  The best performer, the 1024 page size, only had 7 fewer page faults in LRU than in FIFO.  On average, LRU only had about 3 fewer page faults over all 4 series than FIFO.  This speaks to the fact that LRU is an improvement over FIFO, but only slightly.  Also, LRU’s assumption that recent past behavior is a good indicator of future behavior is probably not true during this simulation.  The page numbers appeared to be random.  LRU would likely perform much better than FIFO during a practical scenario.  FIFO also did not appear to suffer from Belady’s anomaly.  </p>
        <p>Based on LRU’s surprisingly average performance, this seems to suggest that designing a program to run around the working set would be advantageous.  At the beginning of a new working set there would be a period of many page faults, but once the majority of it is in memory it will stay there using the LRU algorithm.  This would work well for productivity software where a user needs to stay inside a program for a longer period of time.</p>
        </div>
        </div>





            <!--footer-->
            <footer class="footer">
              <p class="section__title section__title--footer">Interested in a project?  Want to connect?</p>
              <p class="section__title section__title--footer">Contact me here!</p>
              <a href="mailto:druss337@gmail.com" class="footer__link" id="contact">druss337@gmail.com</a>
              <ul class="social-list">


                  <li class="social-list__item"><a class="social-list__link"
                    href="https://github.com/dmruss">
                    <i class="fab fa-github-square"></i></a></li>

                    <li class="social-list__item"><a class="social-list__link"
                      href="https://www.linkedin.com/in/david-russell-1ab47793/">
                      <i class="fab fa-linkedin"></i></a></li>

                    </ul>
            </footer>
            <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
            <script>
            AOS.init();
            </script>
    </body>

    </html>
